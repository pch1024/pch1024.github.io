(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{258:function(e,t,v){"use strict";v.r(t);var _=v(0),o=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vuex"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuex","aria-hidden":"true"}},[e._v("#")]),e._v(" Vuex")]),e._v(" "),v("p",[e._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 "),v("code",[e._v("store")]),e._v("（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。")]),e._v(" "),v("ol",[v("li",[e._v("Vuex 的状态存储是响应式的。当 Vue 组件从 "),v("code",[e._v("store")]),e._v(" 中读取状态的时候，若 "),v("code",[e._v("store")]),e._v(" 中的状态发生变化，那么相应的组件也会相应地得到高效更新。")]),e._v(" "),v("li",[e._v("改变 "),v("code",[e._v("store")]),e._v(" 中的状态的唯一途径就是显式地提交 "),v("code",[e._v("(commit) mutation")]),e._v("。这样使得我们可以方便地跟踪每一个状态的变化。")])]),e._v(" "),v("p",[e._v("包括以下模块：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("State")]),e._v("：定义了应用状态的数据结构，可以在这里设置默认的初始状态。")]),e._v(" "),v("li",[v("code",[e._v("Getter")]),e._v("：允许组件从 Store 中获取数据，"),v("code",[e._v("mapGetters")]),e._v(" 辅助函数仅仅是将 "),v("code",[e._v("store")]),e._v(" 中的 "),v("code",[e._v("getter")]),e._v(" 映射到局部计算属性。")]),e._v(" "),v("li",[v("code",[e._v("Mutation")]),e._v("：是唯一更改 "),v("code",[e._v("store")]),e._v(" 中状态的方法，且必须是同步函数。")]),e._v(" "),v("li",[v("code",[e._v("Action")]),e._v("：用于提交 "),v("code",[e._v("mutation")]),e._v("，而不是直接变更状态，可以包含任意异步操作。")]),e._v(" "),v("li",[v("code",[e._v("Module")]),e._v("：允许将单一的 Store 拆分为多个 "),v("code",[e._v("store")]),e._v(" 且同时保存在单一的状态树中。")])])])}),[],!1,null,null,null);t.default=o.exports}}]);